import pstats
import json
import argparse
import os
import csv

def convert_cprofile_to_json(profile_path, output_path):
    """
    Reads a cProfile stats file and converts it into a structured JSON format.
    """
    if not os.path.exists(profile_path):
        print(f"Error: Profile file not found at {profile_path}")
        return

    stats = pstats.Stats(profile_path)
    stats_list = []

    # The stats.stats dictionary maps function tuples to stat tuples
    # func_tuple -> (primitive_calls, total_calls, total_time, cumulative_time, callers_dict)
    for func, (cc, nc, tt, ct, callers) in stats.stats.items():
        filename, line_number, func_name = func
        
        # Format callers into a more readable list
        formatted_callers = []
        for caller_func, caller_stats in callers.items():
            caller_filename, caller_line, caller_func_name = caller_func
            formatted_callers.append({
                "function": f"{caller_filename}:{caller_line}({caller_func_name})",
                "primitive_calls": caller_stats[0],
                "ncalls": caller_stats[1],
                "total_time_s": caller_stats[2],
                "cumulative_time_s": caller_stats[3],
            })

        stats_list.append({
            "function": f"{filename}:{line_number}({func_name})",
            "primitive_calls": cc,
            "ncalls": nc,
            "total_time_s": tt,
            "cumulative_time_s": ct,
            "callers": formatted_callers
        })

    # Sort functions by cumulative time for easier analysis
    stats_list.sort(key=lambda x: x['cumulative_time_s'], reverse=True)

    with open(output_path, 'w') as f:
        json.dump(stats_list, f, indent=4)
    
    print(f"Successfully converted profile data to {output_path}")

def convert_cprofile_to_csv(profile_path, output_path, top_n=20):
    """
    Reads a cProfile stats file and writes the top N functions by cumulative
    time to a CSV file.
    """
    if not os.path.exists(profile_path):
        print(f"Error: Profile file not found at {profile_path}")
        return

    stats = pstats.Stats(profile_path)
    stats_list = []

    for func, (cc, nc, tt, ct, callers) in stats.stats.items():
        filename, line_number, func_name = func
        stats_list.append({
            "function": f"{filename}:{line_number}({func_name})",
            "primitive_calls": cc,
            "ncalls": nc,
            "total_time_s": tt,
            "cumulative_time_s": ct,
        })

    # Sort functions by cumulative time
    stats_list.sort(key=lambda x: x['cumulative_time_s'], reverse=True)

    # Get the top N functions
    top_stats = stats_list[:top_n]

    # Write to CSV
    with open(output_path, 'w', newline='') as f:
        if not top_stats:
            print("No stats to write.")
            return
        
        writer = csv.DictWriter(f, fieldnames=top_stats[0].keys())
        writer.writeheader()
        writer.writerows(top_stats)

    print(f"Successfully wrote top {top_n} functions to {output_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convert cProfile output to a structured JSON or CSV file.")
    parser.add_argument("profile_file", help="Path to the .prof file generated by cProfile.")
    parser.add_argument("--output", "-o", help="Path for the output file. Defaults to profile_results.json or profile_results.csv.")
    parser.add_argument("--format", choices=['json', 'csv'], default='csv', help="Output format.")
    parser.add_argument("--top", type=int, default=20, help="Number of functions to include in CSV output.")
    
    args = parser.parse_args()

    output_file = args.output
    if not output_file:
        output_file = f"profile_results.{args.format}"

    if args.format == 'json':
        convert_cprofile_to_json(args.profile_file, output_file)
    elif args.format == 'csv':
        convert_cprofile_to_csv(args.profile_file, output_file, args.top)